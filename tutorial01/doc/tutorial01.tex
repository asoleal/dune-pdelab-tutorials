\documentclass[a4paper,12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[a4paper,total={150mm,240mm}]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amscd}
\usepackage{grffile}
\usepackage{tikz} 
\usepackage{eurosym} 
\usepackage{graphicx}
\usepackage{color}
\usepackage{listings}
\lstset{language=C++, basicstyle=\ttfamily, 
  keywordstyle=\color{black}\bfseries, tabsize=4, stringstyle=\ttfamily,
  commentstyle=\itshape, extendedchars=true, escapeinside={/*@}{@*/}}
\usepackage{paralist}
\usepackage{curves}
\usepackage{calc}
\usepackage{picinpar}
\usepackage{enumerate}
\usepackage{algpseudocode}
\usepackage{bm}
\usepackage{multibib}
\usepackage{hyperref}
\usepackage{textcase}
\usepackage{nicefrac}

\definecolor{listingbg}{gray}{0.95}

\title{DUNE PDELab Tutorial 01 \\ 
Conforming Finite Element Method for a Nonlinear Poisson Equation}
\author{DUNE/PDELab Team}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\clearpage

\section{Introduction}

In this tutorial we extend tutorial 00 in the following ways:
\begin{enumerate}[1)]
\item Solve a nonlinear stationary partial differential equation (PDE).
\item Use conforming finite element spaces of arbitrary order.
\item Use different types of (conforming) meshes (simplical, cubed and mixed).
\item Use multiple types of boundary conditions.
\end{enumerate}
Combined with the fact that the implementation works in any dimension
(note: it is not claimed to be efficient in high dimension ($d>3$) this comprises
already a relatively large space of different methods, so the example illustrates
the flexibility of PDELab. Moreover, the 
finite element method developed in this tutorial will serve as a 
building block for instationary problems, adaptive mesh refinement and
parallel solution in subsequent tutorials.

\subsection*{Depends On} 

This tutorial depends on tutorial 00 which discusses piecewise linear elements on simplicial
elements. It is assumed that you have worked through tutorial 00 before.

\section{Problem Formulation}

Here we consider the following nonlinear Poisson equation with
Dirichlet and Neumann boundary conditions:
\begin{align*}
-\Delta u + q(u) &= f &&\text{in $\Omega$},\\
u &= g &&\text{on $\Gamma_D\subseteq\partial\Omega$},\\
-\nabla u\cdot \nu &= j &&\text{on $\Gamma_N=\partial\Omega\setminus\Gamma_D$}.
\end{align*}
$\Omega\subset\mathbb{R}^d$ is a domain, $q:\mathbb{R}\to\mathbb{R}$ is a given, possibly
nonlinear function and $f: \Omega\to\mathbb{R}$ is the source term and
$\nu$ denotes the unit outer normal to the domain.

The weak formulation of this problem is derived by multiplication with an appropriate
test function and integrating by parts. This results in the abstract problem:
\begin{equation}
\text{Find $u\in U$ s.t.:} \quad r^{\text{NLP}}(u,v)=0 \quad \forall v\in V,
\label{Eq:BasicBuildingBlock}
\end{equation}
with the continuous residual form
\begin{equation*}
r^{\text{NLP}}(u,v) = \int_\Omega \nabla u \cdot \nabla v + (q(u)-f)v\,dx + \int_{\Gamma_N} jv\,ds
\label{eq:ResidualForm}
\end{equation*}
and the function spaces 
$U= \{v\in H^1(\Omega) \,:\, \text{``$v=g$'' on $\Gamma_D$}\}$
and $V= \{v\in H^1(\Omega) \,:\, \text{``$v=0$'' on $\Gamma_D$}\}$. 
We assume that $q$ is such that this problem has a unique solution.

\section{Finite Element Method}

The finite element method \cite{WHElliptisch,Brenner,Eriksson,Ciarlet,Braess,Ern,Elman2005} 
replaces the function spaces $U$ and $V$ by
finite dimensional approximations defined on a finite element mesh.
Before describing exactly how these spaces are constructed let us
explore the consequences of this.

\subsection{Algebraic Problem}

Any finite-dimensional function space is spanned by a basis. So, assume that
\begin{equation*}
U_h=\text{span}\{\phi_1,\ldots,\phi_n\}, \quad V_h=\text{span}\{\psi_1,\ldots,\psi_m\}
\end{equation*}
are corresponding sets of basis functions for $U_h$ and $V_h$.
Expanding the solution $u_h=\sum_{j=1}^n (z)_j\phi_j$ in the basis and
hereby introducing the coefficient vector $z\in\mathbb{R}^n$ we can
reformulate the problem as
\begin{align*}
\text{Find $u_h\in U_h$ s.t.:} && r(u_h,v)&=0 && \forall v\in V_h\\
\Leftrightarrow{} && r\left(\sum_{j=1}^n (z)_j\phi_j,\psi_i\right) &= 0 &&\forall i=1,\ldots,m\\
\Leftrightarrow{} && R(z) = 0,
\end{align*}
where $R: \mathbb{R}^n \to \mathbb{R}^m$ given by 
$R_i(z) = r_h\left(\sum_{j=1}^n (z)_j\phi_j,\psi_i\right)$ is a nonlinear, vector-valued function.

The solution of the nonlinear algebraic equation $R(z)=0$ is typically computed
in an iterative fashion using e.g. a fixed-point iteration of the form
\begin{equation}
z^{(k+1)} = G(z^{(k)}) = z^{(k)} - \lambda^{k} W(z^{(k)}) R(z^{(k)}) .
\end{equation}
Here $\lambda^{k}$ is a damping factor
and $W(z^{(k)})$ is a preconditioner matrix, e.g. in Newton's method (see e.g. \cite{Braess}) one
has 
\begin{equation*}
W(z^{(k)}) = (J(z^{(k)}))^{-1} \quad \text{where $(J(z^{(k)}))_{i,j} = \frac{\partial R_i}{\partial z_j}
(z^{(k)})$}
\end{equation*}
(we now assumed that $n=m$ and that the Jacobian $J(z^{(k)})$ is invertible).
Newton's method requires the solution of the linear system $J(z^{(k)}) w = R(z^{(k)})$ in each
step which could be done using either direct or iterative methods.
The implementation of  Newton's method requires the following
algorithmic building blocks:
\begin{enumerate}[i)]
\item residual evaluation $R(z)$,
\item Jacobian evaluation $J(z)$ (or an approximation of it),
\item matrix-free Jacobian application $J(z) w$ (or an approximation).
\end{enumerate}
Only one of the methods i) and ii) is required depending on the chosen
solution procedure.

\subsubsection*{A Note on Matrix-free Evaluation}

The matrix-free multiplication of the Jacobian $J(z)$ with a vector $w$ is with
the definitions above:
\begin{equation*}
(J(z) w)_i = \sum_{j=1}^n (J(z))_{i,j} (w)_j = \sum_{j=1}^n 
\frac{\partial}{\partial z_j} r_h\left(\sum_{l=1}^n (z)_l  \phi_l,\psi_i\right) (w)_j .
\end{equation*}
At this point one may exploit the local support of basis functions in order
to compute only the partial derivatives that are nonzero.

In the linear case, for comparison, one has $r_h(u,v) = a_h(u,v) - l_h(v)$ where
$a_h$ is a bilinear form and $l_h$ is a linear form. Then, the application
of the Jacobian can be simplified as
\begin{equation*}
\begin{split}
(J(z) w)_i &= \sum_{j=1}^n 
\frac{\partial}{\partial z_j} r_h\left(\sum_{l=1}^n (z)_l  \phi_l,\psi_i\right) (w)_j \\
&= \sum_{j=1}^n \frac{\partial}{\partial z_j} \left( 
a_h\left(\sum_{l=1}^n (z)_l  \phi_l,\psi_i\right) - l_h(\psi_i)\right) (w)_j \\
&= \sum_{j=1}^n \frac{\partial}{\partial z_j} \left( 
\sum_{l=1}^n (z)_l a_h(\phi_l,\psi_i) \right)  (w)_j \\
&= \sum_{j=1}^n a_h(\phi_j,\psi_i) (w)_j =
a_h\left( \sum_{j=1}^n (w)_j \phi_j,\psi_i\right) =
(A w)_i 
\end{split}
\end{equation*}
where $(A)_{i,j} = a_h(\phi_j,\psi_i)$ is the stiffness matrix which is independent of $z$.
For this reason there exist two different functions for matrix-free operator application,
one for the linear case providing only the argument $w$ and one for the nonlinear
case providing two arguments $z$ and $w$. 

Note also that it is advantageous to seperate in the
implementation of the residual form the part that depends on trial and test functions,
and which consequently contributes to the Jacobian, and the part that only depends
on the test functions and which does not contribute to the Jacobian.

\subsection{Finite Element Space}

The detailed construction of the basis functions $\phi_j$ involves the finite element mesh.
Wrapping up the notation from tutorial 00, a finite element mesh consists of
\begin{enumerate}[i)]
\item A set of vertices $\mathcal{X}_h = \{x_1,\ldots,x_N\}$ and
elements $\mathcal{T}_h = \{T_1, \ldots, T_M\}$. Elements are closed and connected sets of points
with non-intersecting interior partitioning the domain $\Omega$.
\item A partitioning of the vertex index set $\mathcal{I}_h=\{1,\ldots,N\}$
into indices of interior and boundary vertices
\begin{equation*}
\mathcal{I}_h = \mathcal{I}_h^{int}\cup\mathcal{I}_h^{\partial\Omega},
\quad \mathcal{I}_h^{int} = \{i\in \mathcal{I}_h\,:\, x_i\in\Omega\},
\quad \mathcal{I}_h^{\partial\Omega} = \{i\in \mathcal{I}_h\,:\, x_i\in\partial\Omega\}.
\end{equation*}
\item For every element $T\in\mathcal{T}_h$ a local-to-global map 
$$g_T:\{0,\ldots,n_T-1\}\to\mathcal{I}_h$$ 
associating a local number of a corner of element $T$ with a global vertex number.
$n_T$ is the number of corners of element $T$.
\item For every element $T\in\mathcal{T}_h$ an element transformation map
$$\mu_T : \hat T \to T$$
mapping the corresponding reference element to $T$. The element transformation
map need not be affine but is assumed to be suffiently differentiable with invertible
Jacobian as well as consistent in the sense 
$\forall i\in\{0,\ldots,n_T-1\} : \mu_T(\hat x_i) = x_{g_T(i)}$.
\end{enumerate}

The conforming finite element space of degree $k$ in dimension $d$ on the mesh
$\mathcal{T}_h$ is given by
\begin{equation}
V_h^{k,d}(\mathcal{T}_h) = \left\{ v\in C^0(\overline{\Omega}) \,:\, 
\forall T\in\mathcal{T}_h : v|_T = \mu_T \circ p_T \wedge p_T\in\mathbb{P}_T^{k,d}\right\}
\label{eq:Vh}
\end{equation}
with the appropriate space of multivariate polynomials of degree $k$ in dimension $d$
depending on the type of element $T$:
\begin{equation}
\mathbb{P}_T^{k,d} = \left\{\begin{array}{ll}
\left\{ p\,:\, p(x_1,\ldots,x_d) = \sum\limits_{0\leq\|\alpha\|_1\leq k} c_\alpha
x_1^{\alpha_1}\cdot\ldots\cdot x_d^{\alpha_d}\right\} & \text{$\hat T = \hat S$ (simplex)}, \\
\left\{ p\,:\, p(x_1,\ldots,x_d) = \sum\limits_{0\leq\|\alpha\|_\infty\leq k} c_\alpha
x_1^{\alpha_1}\cdot\ldots\cdot x_d^{\alpha_d}\right\} & \text{$\hat T = \hat C$ (cube)} .
\end{array}\right .
\end{equation}
Note that in dimension $1$ there is no difference between cube and simplex.
In dimension $2$ triangular and quadrilateral elements may be mixed. In 
dimension $3$, however, tetrahedral and hexahedral elements may not be mixed
without introducing additional elements such as prisms.
The dimension of  $\mathbb{P}_T^{k,d}$ is
\begin{equation*}
n_{\hat C}^{k,d} = (k+1)^d
\end{equation*}
in the case of a cube reference element and
\begin{equation*}
n_{\hat S}^{k,d} = \left\{ \begin{array}{ll}
1 & k=0 \vee d=0\\
\sum_{i=0}^k n_{\hat S}^{i,d-1} &\text{else}
\end{array}\right .
\end{equation*}
in the case of a simplex reference element.

\subsubsection*{Local Lagrange Basis}

\eqref{eq:Vh} defines the finite element space without reference to a basis.
For the implementation in the computer a basis is needed. We now generalize
the construction of the Lagrange basis functions to the general space $V_h^{k,d}(\mathcal{T}_h)$.
To that end, the reference element $\hat T$ is equipped with Lagrange  
points 
$$L_{\hat T} = \left\{ \hat x^{\hat T}_0,\ldots,\hat x^{\hat T}_{n_{\hat T}^{k,d}-1} \right\}$$
and Lagrange polynomials 
$$P_{\hat T} = \left\{ p^{\hat T}_0,\ldots,p^{\hat T}_{n_{\hat T}^{k,d}-1}\right\}$$
such that $$p^{\hat T}_i(\hat x^{\hat T}_j) = \delta_{i,j}.$$
Global continuity is then ensured by carefully placing $n_{\hat T}^{k,d-c}$ of these
points on each subentity of codimension $c$ in the reference element. 

\subsubsection*{Global Lagrange Basis}

The local-to-global map $g_T$ is extended to map indices of 
local basis functions to indices of global basis functions of the finite element space.
Let
\begin{equation*}
g_T : \{0,\ldots,n_{\hat T}^{k,d}-1\} \to \mathcal{I}\left(V_h^{k,d}(\mathcal{T}_h)\right) =
\left\{0,\ldots,\text{dim} V_h^{k,d}(\mathcal{T}_h)-1\right\}
\end{equation*}
be this extension and
\begin{equation*}
C(i) = \{(T,m)\in\mathcal{T}_h\times\mathbb{N} \,:\, g_T(m)=i\}
\end{equation*}
its inversion. Then
\begin{enumerate}[i)]
\item $C(i)$ is nonempty for all $i\in\mathcal{I}\left(V_h^{k,d}(\mathcal{T}_h)\right)$ and
\item for all $(T,m), (T',m') \in C(i)$ it holds $\mu_{T}(x^{\hat T}_m)=\mu_{T'}(x^{\hat T'}_{m'})$.
\end{enumerate}
The global Lagrange basis functions spanning $V_h^{k,d}(\mathcal{T}_h)$ are then defined by
\begin{equation*}
\phi_i(x) = \left\{\begin{array}{ll}
p^{\hat T}_m(\mu_T^{-1}(x)) & x\in T \wedge (T,m)\in C(i) \\
0 & \text{else}
\end{array}\right. , \quad i\in\mathcal{I}\left(V_h^{k,d}(\mathcal{T}_h)\right) .
\end{equation*}
Each global basis function $\phi_i$ corresponds to a Lagrange
point $x_i$ from the ordered set
\begin{equation*}
\mathcal{X}_h^{k,d} = \left\{ x_i\in\overline{\Omega} \,:\,
x_i=\mu_T(\hat x^{\hat T}_{m})  \wedge (T,m)\in C(i) \right\}.
\end{equation*}
Note that for
degree $k=1$ one has $\mathcal{I}\left(V_h^{1,d}(\mathcal{T}_h)\right) = \mathcal{I}_h$, i.e. 
one basis function is associated with each vertex of the mesh.

\subsection{Incorporation of Dirichlet Boundary Conditions}

The standard way to handle Dirichlet boundary conditions in the conforming
finite element method is to incorporate them directly into the function space. 
To that define the indices of Lagrange points on the Dirichlet boundary
\begin{equation*}
\mathcal{I}^D\left(V_h^{k,d}(\mathcal{T}_h)\right) = 
\left\{ i\in\mathcal{I}\left(V_h^{k,d}(\mathcal{T}_h)\right)  \,:\,
x_i\in\mathcal{X}_h^{k,d} \wedge x_i\in\Gamma_D  
\right\} .
\end{equation*}

For the test space one defines the space of finite element
functions that are zero on the Dirchlet boundary:
\begin{equation*}
V_{h,0}^{k,d}(\mathcal{T}_{h}) = \left\{ 
v\in V_{h}^{k,d}(\mathcal{T}_{h}) \,:\, v(x_i) = 0 
\quad \forall i\in\mathcal{I}^D\left(V_h^{k,d}(\mathcal{T}_h)\right)
 \right\}
\end{equation*}
For the trial space set
\begin{equation*}
u_{h,g} = \sum_{i\in \mathcal{I}^D\left(V_h^{k,d}(\mathcal{T}_h)\right)}
g(x_i) \phi_i
\end{equation*}
with the Dirichlet boundary condition function $g$. In fact one may want to
use
\begin{equation*}
u_{h,g} = \sum_{i\in \mathcal{I}\left(V_h^{k,d}(\mathcal{T}_h)\right)}
u_g(x_i) \phi_i \qquad \text{with $u_g(x_i)=g(x_i)$ for all $i\in 
\mathcal{I}^D\left(V_h^{k,d}(\mathcal{T}_h)\right)$}
\end{equation*}
which incorporates the Dirichlet boundary conditions on $\Gamma_D$
and provides an initial guess for the nonlinear iterative solver in the
interior of the domain. Then the trial space is
\begin{equation*}
U_{h}^{k,d}(\mathcal{T}_{h}) = \left\{ u\in V_h^{k,d}(\mathcal{T}_h)
\,:\, u = u_{h,g} + w \wedge w\in V_{h,0}^{k,d}(\mathcal{T}_{h})\right\} .
\end{equation*}
Finally, the finite element problem in its precise form reads
\begin{equation}
\text{Find $u\in U_{h}^{k,d}(\mathcal{T}_{h})$ s.t.:} 
\quad r^{\text{NLP}}(u,v)=0 \quad \forall v\in V_{h,0}^{k,d}(\mathcal{T}_{h}) .
\label{eq:PreciseFEProblem}
\end{equation}

\subsubsection*{General Constraints}

PDELab provides a more general approach to construct subspaces of
finite element spaces. Given a
finite-dimensional space $U_h = \text{span}\left\{\phi_j \,:\, j\in J_h=\{1,\ldots,n\}\right\}$
a subspace $\tilde{U}_h$ is constructed by 
\begin{enumerate}[i)]
\item selecting a subset of indices $\tilde{J}_h\subset J_h$
\item and settting $\tilde{U}_h = \text{span}\left\{\tilde\phi_j \,:\, j\in \tilde{J}_h\right\}$,
where the new basis functions have the form 
\begin{equation*}
\tilde\phi_j = \phi_j + \sum_{l\in J_h\setminus\tilde{J}_h} (B)_{j,l} \phi_l \quad \forall j\in \tilde{J}_h.
\end{equation*}
\end{enumerate}
Thus, any subspace of $U_h$ is characterized by $C=(\tilde{J}_h,B)$.
This abstractions allows to represent Dirichlet conditions ($J_h\setminus\tilde{J}_h$
are the indices of the Dirichlet nodes and $B=0$), hanging nodes
($J_h\setminus\tilde{J}_h$ are the indices of hanging nodes and $B$ represents
the interpolation conditions) or even rigid body modes.


\subsection{Element-wise Computations}
\label{Sec:ElementComputations}

We now turn to how the residual can be evaluated in practice.
The residual form \eqref{eq:ResidualForm} can be readily decomposed into
elementwise contributions:
\begin{equation*}
r^{\text{NLP}}\left(u,v\right) =  
\sum_{T\in\mathcal{T}_h} \alpha_T^V(u,v) 
  + \sum_{T\in\mathcal{T}_h} \lambda_T^V(v)
 + \sum_{F\in\mathcal{F}_h^{\partial\Omega}}\lambda_F^B(v)
\end{equation*}
with
\begin{align*}
\alpha_T^V(u,v) &= \int_T \nabla u \cdot \nabla v + q(u) v \,dx, &
\lambda_T^V(v) &= - \int_T f v \,dx, &
\lambda_F^B(v) &= \int_{F\cap\Gamma_N} j v\,ds.
\end{align*}
Here $\mathcal{F}_h^{\partial\Omega}$ is the set of intersections of
elements with the domain boundary, i.e. $F=T_F^-\cap\partial\Omega$
where $T_F^-$ is the element associated with $F$. 
The element-wise computations can be classified on the one hand as volume
integrals (superscript $V$), boundary integrals (superscript $B$) and
skeleton integrals (superscript $S$, to be shown later) and on the
other hand as integrals depending on trial and test functions ($\alpha$-terms)
and integrals depending only on test functions ($\lambda$-terms). Here we need
three of these six possible combinations.

The three terms can now be evaluated using the techniques introduced in 
tutorial 00 with the small extension that for general maps $\mu_T$ we
have 
$$\nabla w(\mu_T(\hat x)) = J_{\mu,T}^{-1}(\hat x) \hat\nabla \hat w (\hat x)$$
with $J_{\mu,T}(\hat x)$ the Jacobian of $\mu_T$ at point $\hat x$.

\subsubsection*{$\lambda$ Volume Term}

For any $(T,m)\in C(i)$ we obtain
\begin{equation*}
\begin{split}
\lambda_T^V(\phi_i) &= - \int_T f \phi_i \,dx = 
- \int_{\hat T} f(\mu_T(\hat x)) p_m^{\hat T}(\hat x) |\text{det} J_{\mu,T}(\hat x)|\, d\hat x .
\end{split}
\end{equation*}
This integral on the reference element is then computed by employing
numerical integration of appropriate order.
The evaluation for all test functions with support on element $T$ may be collected in
a vector 
\begin{equation*}
(\mathcal{L}_T^V)_m = - \int_{\hat T} f(\mu_T(\hat x)) p_m^{\hat T}(\hat x) 
|\text{det} J_{\mu,T}(\hat x)|\, d\hat x.
\end{equation*}

\subsubsection*{$\lambda$ Boundary Term}

For $F\in\mathcal{F}_h^{\partial\Omega}$ with $F\cap\Gamma_N\neq\emptyset$
and $(T_F^-,m)\in C(i)$ we obtain
\begin{equation*}
\begin{split}
\lambda_T^B(\phi_i) &= \int_{F} j v\,ds = 
\int_{\hat F} j(\mu_F(\hat x)) p_m^{\hat T}(\eta_F(\hat x)) 
\sqrt{|\text{det} J^T_{\mu,T}(\hat x)J_{\mu,T}(\hat x)|} \,ds
\end{split}
\end{equation*}
Because integration is over a face of codimension 1 now, two mappings are
involved. The map $\mu_F$ maps the reference element $\hat F$ of $F$ into
global coordinates while the map $\eta_F$ maps $\hat F$ into the referece
element $\hat T$ of $T$. Also the integration element has to redefined accordingly.
Again, all contributions of the face $F$ can e collected in a vector:
\begin{equation*}
(\mathcal{L}_T^V)_m = 
\int_{\hat F} j(\mu_F(\hat x)) p_m^{\hat T}(\eta_F(\hat x)) 
\sqrt{|\text{det} J^T_{\mu,T}(\hat x)J_{\mu,T}(\hat x)|} \,ds .
\end{equation*}

\subsubsection*{$\alpha$ Volume Term}

For any $(T,m)\in C(i)$ we get
\begin{equation*}
\begin{split}
\alpha_T^V(u_h,\phi_i) &= \int_T \nabla u \cdot \nabla \phi_i + q(u) \phi_i \,dx,
= \int_T \sum_j (z)_j \left(\nabla \phi_j \cdot \nabla \phi_i \right) 
+ q\left( \sum_j (z)_j \phi_j \right) \phi_i \,dx,\\
&= \int_{\hat T} \sum_{n} (z)_{g_T(n)} (J_{\mu,T}^{-1}(\hat x) \hat\nabla p_n^{\hat T}(\hat x) )
\cdot (J_{\mu,T}^{-1}(\hat x) \hat\nabla p_m^{\hat T}(\hat x) ) \\
&\hspace{40mm}+ q\left( \sum_n (z)_{g_T(n)} p_n^{\hat T}(\hat x) \right) p_m^{\hat T}(\hat x) 
|\text{det} J_{\mu,T}(\hat x)| \,dx
\end{split}
\end{equation*}
Again contributions for all test functions can be collected in a vector
\begin{equation*}
\begin{split}
(\mathcal{A}_T^V(R_T z))_m &=
\sum_{n} (z)_{g_T(n)} \int_{\hat T} (J_{\mu,T}^{-1}(\hat x) \hat\nabla p_n^{\hat T}(\hat x) )
\cdot (J_{\mu,T}^{-1}(\hat x) \hat\nabla p_m^{\hat T}(\hat x) ) |\text{det} J_{\mu,T}(\hat x)| \,dx\\
&\hspace{30mm}+ \int_{\hat T} q\left( \sum_n (z)_{g_T(n)} p_n^{\hat T}(\hat x) \right) p_m^{\hat T}(\hat x) 
|\text{det} J_{\mu,T}(\hat x)| \,dx
\end{split}
\end{equation*}


\subsubsection*{Putting it all together}

Now with these definitions in place the evaluation of the algebraic residual is
\begin{equation*}
R(z) = 
\sum_{T\in\mathcal{T}_h} R_T^T \mathcal{A}_T^V(R_T z)
  + \sum_{T\in\mathcal{T}_h} R_T^T \mathcal{L}_T^V
 + \sum_{F\in\mathcal{F}_h^{\partial\Omega}\cap\Gamma_N} R_T^T \mathcal{L}_F^B
\end{equation*}

The Jacobian of the residual is
\begin{equation*}
(J(z))_{i,j} = \frac{\partial R_i}{\partial z_j} (z) =
\sum_{(T,m,n) : (T,m)\in C(i) \wedge (T,n)\in C(j)} \frac{\partial (\mathcal{A}_T^V)_m}{\partial z_n}
(R_T z)
\end{equation*}
Note that:
\begin{enumerate}[a)]
\item Entries of the Jacobian can be computed element by element.
\item The derivative is independent of the $\lambda$-terms as
they only depend on the test functions.
\item In the implementation below the Jacobian is computed numerically
by finite differences. This can be achieved automatically by deriving from an
additional base class.
\end{enumerate}

\section{Realization in PDELab}

The structure of the code is very similar to that of tutorial 00. It consists of the following
files:
\begin{enumerate}[1)]
\item The main file \lstinline{tutorial01.cc} includes the necessary C++,
DUNE and PDELab header files
and contains the \lstinline{main} function where the execution starts. The ini-file
\lstinline{tutorial01.ini} holds parameters read by various parts of the code
which control the execution. The purpose of the \lstinline{main} function is
to instantiate DUNE grid objects and call the \lstinline{driver} function.
\item File \lstinline{driver.hh} instantiates the necessary PDELab classes 
for solving a nonlinear stationary problem and finally solves the problem.
\item File \lstinline{nonlinearpoissonfem.hh} contains the class
\lstinline{NonlinearPoissonFEM} realizing a PDELab local operator implementing
the conforming finite element method for arbitrary order and on arbitrary meshes.
\item File \lstinline{problem.hh} contains a so-called parameter class which
encapsulates the user-definable part of the PDE problem such as right hand
side and boundary conditions.
\item Finally, the tutorial provides some mesh files.
\end{enumerate}

\subsection{Function \lstinline{main}}

\subsection{Function \lstinline{driver}}

\subsection{Local Operator \lstinline{NonlinearPoissonFEM}}

\subsection{Running the Example}

% bibtex bibliography
\bibliographystyle{plain}
\bibliography{tutorial01.bib}

\end{document}
