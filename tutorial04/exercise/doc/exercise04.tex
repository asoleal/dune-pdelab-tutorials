\documentclass[12pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[a4paper,total={150mm,240mm}]{geometry}
\usepackage[american]{babel}

\usepackage{float}
\usepackage{babel}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{wrapfig}
\usepackage{todonotes}

\usepackage{listings}
\definecolor{listingbg}{gray}{0.95}
\lstset{
  language=C++,
  basicstyle=\ttfamily\small,
  frame=single,
  backgroundcolor=\color{listingbg},
  breaklines=true,
  postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
  }


\newcommand{\vx}{\vec x}
\newcommand{\grad}{\vec \nabla}
\newcommand{\wind}{\vec \beta}
\newcommand{\Laplace}{\Delta}
\newcommand{\mycomment}[1]{}


% Exercise stylesheet
\usepackage{exercise}

\title{\textbf{Exercises for Tutorial04}}
\subtitle{Finite Elements for the Wave  Equation}
\exerciselabel{Exercise}

\begin{document}

\exerciseheader

In this exercise you will:
\begin{itemize}
\item Work on the problem presented in the \lstinline{tutorial04}.
\item Modify the implementation to test different time discretizations. 
\item Work with higher order elements and block ordering.
\item Implement your own local operator that represents elliptic coupling (see Tutorial notes and Eriksson et al. \cite{Eriksson})
\item Check the energy conservation property.
\end{itemize}

\begin{Exercise}{Getting to Know the Code}

  \lstset{language=bash}

  The code of \textbf{exercise04} solves the wave equation formulated as a system. As already explained in the \lstinline{tutorial04}
  \begin{align}
    \partial_t u-\Delta u+q(u) &= f && \text{in }\Omega\times\Sigma =
    (0,1)^d \times (t_0, T], \\
    u(x,t) & =g(x,t) && \text{on }\Gamma_D\subseteq\partial\Omega, \\
    -\nabla u(x,t) \cdot \vec{n} &= j(x,t) &&
    \text{on }\Gamma_N=\partial\Omega\setminus\Gamma_D, \\
    u(x,t_0)&=u_0(x) && \text{at } t=t_0
  \end{align}
  with the following choices applied:
  \begin{align}
    \label{ch1:first}
    q(u) &= \eta u^2 \\
    f &= 0 \\
    \Gamma_D &= \{x \in\partial\Omega \mid x_0 = 0 \} \\
    g(x,t) &= \sin(2\pi t) \prod_{i=1}^{d-1} \sin(\pi x_i)^2
    \sin(10\pi x_i)^2\\
    j(x,t) &= 0 \\
    u_0(x) &= 0 \\
    \label{ch1:last}
    t_0&=0 .
  \end{align}

  The code to this exercise can be recompiled individually \textbf{in
    your build directory} by typing make:
  \begin{lstlisting}
  [user@localhost]$ cd release-build/dune-pdelab-tutorials/tutorial03/exercise/src
  [user@localhost]$ make
  \end{lstlisting}

  The structure of the code is very similar to the previous tutorials,
  it consists of the following files:
  \begin{itemize}
  \item \lstinline!exercise03.cc! -- main program,
  \item \lstinline!driver.hh! -- driver to solve problem on a gridview,
    hard-codes $t_0=0$
  \item \lstinline!problem.hh! -- problem parameter class, definitions
    of $q(u)$, $f$, $\Gamma_D$, $\Gamma_N$, $g$ and $j$
  \item \lstinline!nonlinearheatfem.hh! instationary spatial and
    temporal local operators $r(u,v,t)$ and $m(u,v,t)$ respectively .
  \end{itemize}
  As in the previous exercises you can control most of the settings
  through the ini-file \lstinline!tutorial03.ini!. Get an overview of
  the configurable settings, compile and run \lstinline!exercise03!.

  The program writes output with the extension \lstinline!pvd!. This is one
  of several ways to write VTK output for the instationary case,
  c.f. the documentation of the tutorial03. The \lstinline!pvd!-file can
  be visualized by ParaView and it consists of a collection of the
  corresponding \lstinline!vtu!-files.
  One big advantage of this approach is that the physical time can be
  printed out. This can be achieved by using the ``AnnotateTimeFiler``
  in ParaView.

\end{Exercise}




\begin{Exercise}{Poisson Equation with Piecewise Linear Elements}



\begin{enumerate}
\item {\sc Warming up}:\\
  The code presented in this tutorial solves the following elliptic
  equation with Dirichlet boundary conditions
  \begin{align*}
    \begin{array}{rcll}
      -\Laplace u  & = & f & \text{ in } \Omega, \\
      u & = & g & \text{ on } \partial\Omega,
    \end{array}
  \end{align*}
  where
  \begin{align*}
    f(x) = -2d \quad\text{and}\quad  g(x) = \sum_{i=1}^d (x)_i^2.
  \end{align*}

  First of all check that $u(x) = \sum_{i=1}^d (x)_i^2$ is a solution
  in any dimension $d$.

  For general instructions how to modify the sources and rebuilding
  the program see the exercise-workflow in the \lstinline{overview} folder.  
  
  
  We now want to run the program for different grid
  refinement levels.  The source file for this exercise is called
  \lstinline{exercise0.cc}.  What the program does is controlled by
  the file \lstinline{tutorial00.ini}:
  \lstinputlisting[language=bash]{../src/tutorial04.ini}

  Here you may change the dimension, the number of mesh refinements
  and the names of input and output files. In dimension 1 the
  extension \lstinline{.vtp} is added and in dimension 2 and 3
  \lstinline{.vtu} is added.

  In order to generate a set of output files you may set
  \begin{lstlisting}
refinement=0
  \end{lstlisting}
  and
  \begin{lstlisting}
[output]
filename=solution_0
  \end{lstlisting}
  and then
  \begin{lstlisting}
refinement=1
  \end{lstlisting}
  and
  \begin{lstlisting}
[output]
filename=solution_1
  \end{lstlisting}
  and so on.  You don't have to rebuild your program after changing
  the ini file.

  Now run the program for these settings. The solutions can be
  visualized using ParaView.  Note that you must press the
  \lstinline{Apply} button in the paraview user interface to see the
  loaded vtu/vtp files.  Use the Calculator filter to visualize the
  difference $|u-u_h|$ and determine the maximum error. Note that $u$
  and $u_h$ are called \lstinline{exact} and \lstinline{fesol} in
  the parview output.

\item {\sc Solving a new problem}:

  Now consider
  \begin{align}
    f(x) =  -\sum_{i=1}^d 6(x)_i \quad\text{and}\quad  g(x) = \sum_{i=1}^d (x)_i^3
  \end{align}
  and check that $u(x)=\sum_{i=1}^d (x)_i^3$ solves the PDE.

  Implement the new $f$ and $g$ functions in the files
  \lstinline{ffunction.hh} and \lstinline{gfunction.hh}
  respectively. Recompile and run the program accordingly.

\item {\sc Analysis of finite element error}:

  Produce now a sequence of output files for different levels of mesh
  refinement $0, 1, 2, \ldots$. Visualize the error $|u-u_h|$ in
  ParaView and determine the maximum error on each level.  Make a
  table and determine the convergence rate.

\item {\sc Use a different solver}:

You may also try to exchange the iterative linear solver by
replacing it with the following lines:
\begin{lstlisting}
typedef Dune::PDELab::ISTLBackend_SEQ_BCGS_SSOR LS;
LS ls(5000,true);
\end{lstlisting}
Compare the number of iterations which is given by the following lines
in the output (here we have 12 iterations):
\begin{lstlisting}
=== CGSolver
   12       1.9016e-09
=== rate=0.144679, T=0.02362, TIT=0.00196833, IT=12
\end{lstlisting}
\end{enumerate}
\end{Exercise}


\begin{Exercise}{Changing the Local Operator}

Now consider the extended equation of the form
\begin{align}
    \begin{array}{rcll}
      -\nabla\cdot (k(x) \nabla u) +a(x) u  & = & f & \text{ in } \Omega, \\
      u & = & g & \text{ on } \partial\Omega,
    \end{array}
\end{align}
with scalar functions $k(x)$, $a(x)$.

\begin{enumerate}
\item In a first step show that the weak formulation of the problem
  involves the new bilinear form
  \begin{align}
    a(u,v) = \int_\Omega k(x) \nabla u(x) \cdot \nabla v(x) + a(x) u(x) v(x) \,dx .
  \end{align}
\item The main work is now to extend the local operator given by the
  class \lstinline{PoissonP1}. This is done in several steps:
  \begin{itemize}
  \item Copy class \lstinline{PoissonP1} to a new file and rename it.
  \item Provide analytic functions for $k(x)$ and $a(x)$ and pass
    GridFunctions to the local operator like it is done for $f(x)$.
  \item Extend the local operator to first handle $k(x)$ by assuming the
    function $k(x)$ to be \emph{constant} on mesh elements.
  \item Now extend the local operator to handle $a(x) u(x)$. Also assume
    the function $a(x)$ to be \emph{constant} on mesh elements.
  \end{itemize}
\item Plug in your new local operator in the driver code and test it.
  In the solution the code is tested for $k(x)=2(x)_1$,
  $a(x)=\sum_{i=1}^{d}(x)_i$ and $g=\sum_{i=1}^d (x)_i^3$ by choosing
  the right hand side $f(x)$ in such a way that $u(x)=\sum_{i=1}^d
  (x)_i^3$ solves the PDE.
\end{enumerate}
\end{Exercise}

\bibliographystyle{plain}
\bibliography{exercise04.bib}

\end{document}
