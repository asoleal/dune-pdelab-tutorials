\documentclass[12pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[a4paper,total={150mm,240mm}]{geometry}
\usepackage[american]{babel}

\usepackage{float}
\usepackage{babel}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{wrapfig}
\usepackage{todonotes}

\usepackage{listings}
\definecolor{listingbg}{gray}{0.95}
\lstset{
  language=C++,
  basicstyle=\ttfamily\small,
  frame=single,
  backgroundcolor=\color{listingbg},
  breaklines=true,
  postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
  }


\newcommand{\vx}{\vec x}
\newcommand{\grad}{\vec \nabla}
\newcommand{\wind}{\vec \beta}
\newcommand{\Laplace}{\Delta}
\newcommand{\mycomment}[1]{}


% Exercise stylesheet
\usepackage{exercise}

\title{\textbf{Exercises for Tutorial04}}
\subtitle{Finite Elements for the Wave  Equation}
\exerciselabel{Exercise}

\begin{document}

\exerciseheader

In this exercise you will:
\begin{itemize}
\item Work on the problem presented in the \lstinline{tutorial04}.
\item Try various time integrators, in particular the Crank-Nicolson method.
\item Explore polynomial degree greater than $2$ by changing the blocking
to \lstinline{none}.
\item Implement your own local operator that represents elliptic projection method (see Tutorial notes and Eriksson et al. \cite{Eriksson})
\item Check the energy conservation property in the numerical scheme.
\end{itemize}

\begin{Exercise}{Getting to Know the Code}

  \lstset{language=bash}

  The code of \textbf{exercise04} solves the the wave equation formulated as a first order in time system. As already explained in the \lstinline{tutorial04} by renaming $u_0=u$ and introducing $u_1=\partial_t u_0 =\partial_t u$ we can write the wave equation as a system of two equations:
\begin{subequations}
\label{eq:SystemForm1}
\begin{align}
\partial_t u_1 - c^2\Delta u_0 &=0 &&\text{in $\Omega\times\Sigma$}, \label{eq:2a}\\
\partial_t u_0 - u_1 &=0 &&\text{in $\Omega\times\Sigma$}, \label{eq:2b}\\
u_0 &= 0 &&\text{on $\partial\Omega$},\\
u_1 &= 0 &&\text{on $\partial\Omega$},\\
u_0 &= q &&\text{at $t=0$},\\
u_1 &= w &&\text{at $t=0$}.
\end{align}
\end{subequations}
Since $u_0=u=0$ on the boundary we also have $\partial_t u = u_1 = 0$ on the boundary.
But one may also omit the boundary condition on $u_1$.  
  

  The code to this exercise can be recompiled individually \textbf{in
    your build directory} by typing make:
  \begin{lstlisting}
  [user@localhost]$ cd release-build/dune-pdelab-tutorials/tutorial04/exercise/src
  [user@localhost]$ make
  \end{lstlisting}

  The structure of the code is very similar to the previous tutorials,
  it consists of the following files:
  \begin{itemize}
  \item \lstinline!exercise04.ini! -- holds parameters read by various parts of the code which control the execution,
  \item \lstinline!exercise04.cc! -- main program, 
  \item \lstinline!driver.hh! -- instantiates the necessary PDELab classes for solving a linear instationary problem and finally solves the problem,
  \item \lstinline!wavefem.hh! -- contains the local operator classes WaveFEM and WaveL2 realizing the spatial and temporal residual forms $r(u,v,t)$ and $m(u,v,t)$ respectively.
  \end{itemize}
  
  As in the previous exercises you can control most of the settings
  through the ini-file \lstinline!exercise04.ini!. Get an overview of
  the configurable settings, compile and run \lstinline!exercise04!.

  The program writes output with the extension \lstinline!pvd!. This is one
  of several ways to write VTK output for the instationary case,
  c.f. the documentation of the tutorial03. The \lstinline!pvd!-file can
  be visualized by ParaView and it consists of a collection of the
  corresponding \lstinline!vtu!-files.
  One big advantage of this approach is that the physical time can be
  printed out. This can be achieved by using the ``AnnotateTimeFiler``
  in ParaView. To see 1D solution, one can apply ''Plot Over Line '' filer, note that our solution is depicted by $u_0$.

\end{Exercise}

\begin{Exercise}{ Try various time integrators, in particular the Crank-Nicolson method}

 \paragraph{Step 2: Arbitrary one-step schemes}
  We want to examine the numerical solution under three different time
  discretization schemes -- Implicit Euler, Crank-Nicolson and
  Fractional-Step-$\theta$. In order to change the time discretization
  scheme you will have to go to the file \lstinline!driver.hh! and
  search for the line
  \begin{lstlisting}
    Dune::PDELab::Alexander2Parameter<RF> pmethod;
  \end{lstlisting}
  Change this to use the
  \lstinline!Dune::PDELab::ImplicitEulerParameter<RF>!, compile and
  rerun the simulation. The program reports the progress of the time
  stepping and the method used. Convince yourself that you are using
  indeed the Implicit Euler. The other two time stepping methods can be
  applied similarly.

  \textbf{Note that} there is no special one step parameter class for
  Crank-Nicolson.  Crank-Nicolson is however the special case of the one
  step $\theta$ scheme with $\theta=0.5$.  So you can create a parameter
  object for Crank-Nicolson with
  \lstinline!Dune::PDELab::OneStepThetaParameter<Real>(0.5)!.  A parameter
  object for the Fractional Step $\theta$ scheme can be created with
  \lstinline!Dune::PDELab::FractionalStepParameter<Real>()!.

\end{Exercise}

\begin{Exercise}{ Explore polynomial degree greater than $2$ by changing the blocking
to \lstinline{none}. }

\end{Exercise}


\begin{Exercise}{Poisson Equation with Piecewise Linear Elements}



\begin{enumerate}
\item {\sc Warming up}:\\
  The code presented in this tutorial solves the following elliptic
  equation with Dirichlet boundary conditions
  \begin{align*}
    \begin{array}{rcll}
      -\Laplace u  & = & f & \text{ in } \Omega, \\
      u & = & g & \text{ on } \partial\Omega,
    \end{array}
  \end{align*}
  where
  \begin{align*}
    f(x) = -2d \quad\text{and}\quad  g(x) = \sum_{i=1}^d (x)_i^2.
  \end{align*}

  First of all check that $u(x) = \sum_{i=1}^d (x)_i^2$ is a solution
  in any dimension $d$.

  For general instructions how to modify the sources and rebuilding
  the program see the exercise-workflow in the \lstinline{overview} folder.  
  
  
  We now want to run the program for different grid
  refinement levels.  The source file for this exercise is called
  \lstinline{exercise0.cc}.  What the program does is controlled by
  the file \lstinline{tutorial00.ini}:
  \lstinputlisting[language=bash]{../src/exercise04.ini}

  Here you may change the dimension, the number of mesh refinements
  and the names of input and output files. In dimension 1 the
  extension \lstinline{.vtp} is added and in dimension 2 and 3
  \lstinline{.vtu} is added.

  In order to generate a set of output files you may set
  \begin{lstlisting}
refinement=0
  \end{lstlisting}
  and
  \begin{lstlisting}
[output]
filename=solution_0
  \end{lstlisting}
  and then
  \begin{lstlisting}
refinement=1
  \end{lstlisting}
  and
  \begin{lstlisting}
[output]
filename=solution_1
  \end{lstlisting}
  and so on.  You don't have to rebuild your program after changing
  the ini file.

  Now run the program for these settings. The solutions can be
  visualized using ParaView.  Note that you must press the
  \lstinline{Apply} button in the paraview user interface to see the
  loaded vtu/vtp files.  Use the Calculator filter to visualize the
  difference $|u-u_h|$ and determine the maximum error. Note that $u$
  and $u_h$ are called \lstinline{exact} and \lstinline{fesol} in
  the parview output.

\item {\sc Solving a new problem}:

  Now consider
  \begin{align}
    f(x) =  -\sum_{i=1}^d 6(x)_i \quad\text{and}\quad  g(x) = \sum_{i=1}^d (x)_i^3
  \end{align}
  and check that $u(x)=\sum_{i=1}^d (x)_i^3$ solves the PDE.

  Implement the new $f$ and $g$ functions in the files
  \lstinline{ffunction.hh} and \lstinline{gfunction.hh}
  respectively. Recompile and run the program accordingly.

\item {\sc Analysis of finite element error}:

  Produce now a sequence of output files for different levels of mesh
  refinement $0, 1, 2, \ldots$. Visualize the error $|u-u_h|$ in
  ParaView and determine the maximum error on each level.  Make a
  table and determine the convergence rate.

\item {\sc Use a different solver}:

You may also try to exchange the iterative linear solver by
replacing it with the following lines:
\begin{lstlisting}
typedef Dune::PDELab::ISTLBackend_SEQ_BCGS_SSOR LS;
LS ls(5000,true);
\end{lstlisting}
Compare the number of iterations which is given by the following lines
in the output (here we have 12 iterations):
\begin{lstlisting}
=== CGSolver
   12       1.9016e-09
=== rate=0.144679, T=0.02362, TIT=0.00196833, IT=12
\end{lstlisting}
\end{enumerate}
\end{Exercise}


\begin{Exercise}{Changing the Local Operator}

Now consider the extended equation of the form
\begin{align}
    \begin{array}{rcll}
      -\nabla\cdot (k(x) \nabla u) +a(x) u  & = & f & \text{ in } \Omega, \\
      u & = & g & \text{ on } \partial\Omega,
    \end{array}
\end{align}
with scalar functions $k(x)$, $a(x)$.

\begin{enumerate}
\item In a first step show that the weak formulation of the problem
  involves the new bilinear form
  \begin{align}
    a(u,v) = \int_\Omega k(x) \nabla u(x) \cdot \nabla v(x) + a(x) u(x) v(x) \,dx .
  \end{align}
\item The main work is now to extend the local operator given by the
  class \lstinline{PoissonP1}. This is done in several steps:
  \begin{itemize}
  \item Copy class \lstinline{PoissonP1} to a new file and rename it.
  \item Provide analytic functions for $k(x)$ and $a(x)$ and pass
    GridFunctions to the local operator like it is done for $f(x)$.
  \item Extend the local operator to first handle $k(x)$ by assuming the
    function $k(x)$ to be \emph{constant} on mesh elements.
  \item Now extend the local operator to handle $a(x) u(x)$. Also assume
    the function $a(x)$ to be \emph{constant} on mesh elements.
  \end{itemize}
\item Plug in your new local operator in the driver code and test it.
  In the solution the code is tested for $k(x)=2(x)_1$,
  $a(x)=\sum_{i=1}^{d}(x)_i$ and $g=\sum_{i=1}^d (x)_i^3$ by choosing
  the right hand side $f(x)$ in such a way that $u(x)=\sum_{i=1}^d
  (x)_i^3$ solves the PDE.
\end{enumerate}
\end{Exercise}

\bibliographystyle{plain}
\bibliography{exercise04.bib}

\end{document}
