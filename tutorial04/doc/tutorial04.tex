\documentclass[a4paper,12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[a4paper,total={150mm,240mm}]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amscd}
\usepackage{grffile}
\usepackage{tikz} 
\usepackage{eurosym} 
\usepackage{graphicx}
\usepackage{color}
\usepackage{listings}
\lstset{language=C++, basicstyle=\ttfamily, 
  keywordstyle=\color{black}\bfseries, tabsize=4, stringstyle=\ttfamily,
  commentstyle=\itshape, extendedchars=true, escapeinside={/*@}{@*/}}
\usepackage{paralist}
\usepackage{curves}
\usepackage{calc}
\usepackage{picinpar}
\usepackage{enumerate}
\usepackage{algpseudocode}
\usepackage{bm}
\usepackage{multibib}
\usepackage{hyperref}
\usepackage{textcase}
\usepackage{nicefrac}

\definecolor{listingbg}{gray}{0.95}

\title{DUNE PDELab Tutorial 04 \\ 
Finite Elements for the Wave Equation}
\author{DUNE/PDELab Team}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\clearpage

\section{Introduction}

In this tutorial we solve the wave equation formulated as a first order
in time system. This way the example serves as a model for the 
treatment of systems of partial differential equations in PDELab.

\subsection*{Depends On} This tutorial depends on tutorial 01 and 03.

\section{PDE Problem}

As an example for a system we consider the wave equation with reflective boundary conditions:
\begin{subequations}
\label{eq:WaveEquation}
\begin{align}
\partial_{tt} u-c^2\Delta u  &= 0 &&\text{in $\Omega\times\Sigma$},\\
u &= 0 &&\text{on $\partial\Omega$},\\
u &= q &&\text{at $t=0$},\\
\partial_t u &= w &&\text{at $t=0$},
\end{align}
\end{subequations}
where $c$ is the speed of sound.
Renaming $u_0=u$ and introducing $u_1=\partial_t u_0 =\partial_t u$ we can write the wave equation as a system of two equations:
\begin{subequations}
\label{eq:SystemForm1}
\begin{align}
\partial_t u_1 - c^2\Delta u_0 &=0 &&\text{in $\Omega\times\Sigma$}, \label{eq:2a}\\
\partial_t u_0 - u_1 &=0 &&\text{in $\Omega\times\Sigma$}, \label{eq:2b}\\
u_0 &= 0 &&\text{on $\partial\Omega$},\\
u_0 &= q &&\text{at $t=0$},\\
u_1 &= w &&\text{at $t=0$}.
\end{align}
\end{subequations}
Note that there are no constraints on the function space for $u_1$
and neither are there boundary conditions for the equation $u_1=\partial_t u_0$.

Note that there are several alternative ways how to write the scalar equation
\eqref{eq:WaveEquation} as a system of PDEs:
\begin{itemize}
\item Eriksson et al. in \cite{Eriksson} apply the Laplacian to
equation \eqref{eq:2b}
$$\Delta \partial_t u_0 - \Delta u_1 = 0$$
which has advantages for energy conservation but requires additional smoothness
properties.
\item Alternatively, we may introduce the abbreviations
$q=\partial_t u$ and $w=-\nabla u$, so $\partial_{tt} u - c^2 \Delta u =
\partial_{tt} u - \nabla\cdot\nabla u = \partial_{t} q + \nabla\cdot w = 0$.
Taking partial derivatives of the introduced variables we obtain $\partial_{x_i} q=
\partial_{x_i} \partial_t u = \partial_t \partial_{x_i}  u = - \partial_t w_i$. This results
in a first-order hyperbolic system of PDEs for $q$ and $w$
\begin{align*}
\partial_t q - c^2 \nabla\cdot w &= 0\\
\partial_t w + \nabla q &= 0
\end{align*}
which are called equations of linear acoustics \cite{LeVeque}. This formulation 
is physically more relevant. It can be modified to handle discontinuous material
properties and upwind finite volume methods can be used for numerical treatment.
\end{itemize}

Here we will stay, however, with the simplest formulation \eqref{eq:SystemForm1}
for simplicity.

\subsection*{Weak Formulation}

Multiplying \eqref{eq:2a}
with test function $v_0$ and \eqref{eq:2b} with test function $v_1$
and using integration by parts we arrive at the weak formulation: Find $(u_0(t),u_1(t))\in
U_0\times U_1$ s.t.
\begin{equation}
\label{eq:WeakForm}
\begin{split}
d_t &\left[ (u_0,v_1)_{0,\Omega} + (u_1,v_0)_{0,\Omega}\right] \\
&\hspace{20mm}+ \left[ c^2 (\nabla u_0,\nabla v_0)_{0,\Omega} -(u_1,v_1)_{0,\Omega} \right] = 0 
\quad \forall (v_0,v_1)\in U_0\times U_1
\end{split}
\end{equation}
where we used the notation of the $L^2$ inner product $(u,v)_{0,\Omega} = \int_\Omega
u v \, dx$.
We readily identify the temporal and spatial residual forms:
\begin{align*}
m^{\text{WAVE}}((u_0,u_1),(v_0,v_1)) &= (u_0,v_1)_{0,\Omega} + (u_1,v_0)_{0,\Omega},\\
r^{\text{WAVE}}((u_0,u_1),(v_0,v_1)) &= c^2 (\nabla u_0,\nabla v_0)_{0,\Omega} - (u_1,v_1)_{0,\Omega} .
\end{align*}
The spaces $U_0$ and $U_1$ are different as $U_0$ incorporates homogeneous 
Dirichlet boundary conditions and $U_1$ employs no boundary conditions.

\subsection*{Generalization}

The abstract setting of PDELab with its weighted residual formulation
carries over to the case of systems of
partial differential equations when cartesian products of
functions spaces are introduced, i.e. the abstract \textit{stationary} problem then reads
\begin{equation}
\text{Find $u_h\in U_h=U_h^1\times \ldots \times U_h^s$ s.t.:} \quad r_h(u_h,v)=0 
\quad \forall v\in V_h=V_h^1\times\ldots\times V_h^s
\label{Eq:BasicSystemBuildingBlock}
\end{equation}
with $s$ the number of components in the system. Again the concepts
are completely orthogonal meaning that $r_h$ might be affine linear or nonlinear
in its first argument and the instationary case works as well.

From an organizational point of view it makes sense to allow that
a component space $U_h^i$ in the cartesian product is itself 
a product space. This naturally leads to a \textit{tree structure} in the
function spaces.

Consider as an example the Stokes equation in $d$ space dimensions.
There one has pressure $p$ and velocity $v$ with components $v_1,\ldots,v_d$
as unknowns. An appropriate function space then would be
$$ U = (P,(V^1,\ldots,V^d)).$$

\section{Finite Element Method}

The finite element method applied to \eqref{eq:WeakForm} is straightforward.
We may use the conforming space $V_h^{k,d}(\mathcal{T}_h)$ of degree $k$ 
in dimension $d$ for each of the components. Typically one would choose
the same polynomial degree for both components.

\section{Realization in PDELab}

The structure of the code is very similar to that of tutorial 01 and 03. 
It consists of the following files:
\begin{enumerate}[1)]
\item The ini-file
\lstinline{tutorial04.ini} holds parameters read by various parts of the code
which control the execution. 
\item The main file \lstinline{tutorial04.cc} includes the necessary C++,
DUNE and PDELab header files
and contains the \lstinline{main} function where the execution starts. 
The purpose of the \lstinline{main} function is
to instantiate DUNE grid objects and call the \lstinline{driver} function.
\item File \lstinline{driver.hh} instantiates the necessary PDELab classes 
for solving a nonlinear stationary problem and finally solves the problem.
\item File \lstinline{wavefem.hh} contains the local operator classes
\lstinline{WaveFEM} and \lstinline{WaveL2} realizing the spatial
and temporal residual forms.
\end{enumerate}

\subsection{Ini-File}

The ini-file contains the usual sections for structured and 1d grids. The
\lstinline{fem} section is the same as in tutorial 01 and allows to set
the polynomial degree, temporal integration order and the time step size.
The \lstinline{problem} section has a new parameter for the speed of sound.
\lstinputlisting[basicstyle=\ttfamily\small,
frame=single,
backgroundcolor=\color{listingbg}]{../src/tutorial04.ini}

\subsection{Function \lstinline{main}}

The \lstinline{main} function is very similar to the one in tutorial 03.
In order to simplify things just structured grids \lstinline{OneDGrid}
and \lstinline{YaspGrid} are used.

\subsection{Function \lstinline{driver}}

The \lstinline{driver} function gets a grid view, a finite element
map and a parameter tree and its purpose is to solve the problem on
the given mesh.
\lstinputlisting[linerange={6-8},
basicstyle=\ttfamily\small,
frame=single,
backgroundcolor=\color{listingbg}]{../src/driver.hh}

There are several changes now in the driver due to the system of PDEs.
The first step is to set a the grid function space using the given finite
element map:
\lstinputlisting[linerange={15-18},
basicstyle=\ttfamily\small,
frame=single,
backgroundcolor=\color{listingbg}]{../src/driver.hh}

The next step is to set up the product space containing
two components. This is done by the following code section:
\lstinputlisting[linerange={21-26},
basicstyle=\ttfamily\small,
frame=single,
backgroundcolor=\color{listingbg}]{../src/driver.hh}
PDELab offers two different class templates to build product spaces. The
one used here is \lstinline{PowerGridFunctionSpace} which creates
a product of a compile-time given number (2 here)
of \textit{identical} function spaces (\lstinline{GFS0} here)
which may only differ in the constraints. With the 
class template \lstinline{CompositeGridFunctionSpace} you can create
a product space where all components might be different spaces. 

An important aspect of product spaces is the ordering of the corresponding degrees 
of freedom. Often the solvers need to exploit an underlying block structure
of the matrices. 

This works in two stages: An ordering has first to be specified when creating product spaces
which is then subsequently exploited in the backend.
Here we use the \lstinline{EntityBlockedOrderingTag} to specify that all degrees of 
freedom related to a geometric entity should be numbered consecutively in
the coefficient vector. Other options are the \lstinline{LexicographicOrderingTag}
ordering first all degrees of freedom of the first component space, then
all of the second component space and so on.
With the Iterative Solver Template Library ISTL it is now
possible to exploit the block structure at compile-time. 
Here we use the tag \lstinline{fixed} in the ISTL vector backend to indicate
that at this level we want to create blocks of fixed size (in this case the block size will be two --
corresponding to the degrees of freedom per entity). Another option
would be the tag \lstinline{none} which is the default. Then the degrees
of freedom are still ordered in the specified way but no block structure is
introduced on the ISTL level. \textit{Important notice:} Using fixed block
structure in ISTL requires that there is the same number of degrees of freedom
per entity. This is true for polynomial degrees one and two but \textit{not}
for higher polynomial degree! 

In order to define a function that specifies the initial value we can
use the same techniques as in the scalar case. We first define a lambda
closure
\lstinputlisting[linerange={29-34},
basicstyle=\ttfamily\small,
frame=single,
backgroundcolor=\color{listingbg}]{../src/driver.hh}
now returning now two components in a \lstinline{FieldVector}.
The first component is the initial value for $u$ the second component
is the initial value for $\partial_t u$. Then a PDELab grid function
can be constructed from the lambda closure
\lstinputlisting[linerange={35-35},
basicstyle=\ttfamily\small,
frame=single,
backgroundcolor=\color{listingbg}]{../src/driver.hh}

Using the grid function a coefficient vector can now be initialized:
\lstinputlisting[linerange={38-40},
basicstyle=\ttfamily\small,
frame=single,
backgroundcolor=\color{listingbg}]{../src/driver.hh}

Given a product function space it is also possible to
extract the individual component spaces from the product
space. This is done by the following code section:
\lstinputlisting[linerange={43-48},
basicstyle=\ttfamily\small,
frame=single,
backgroundcolor=\color{listingbg}]{../src/driver.hh}
In fact, one could have a tree-tructured function space and
extract an arbitrary node as a function space.

The component spaces can now be used to build
up discrete grid functions for the two solution components:
\lstinputlisting[linerange={51-54},
basicstyle=\ttfamily\small,
frame=single,
backgroundcolor=\color{listingbg}]{../src/driver.hh}
Note that the full solution vector \lstinline{z} is passed as an argument.
The subspace automatically extracts the required components from the solution vector.
 

\section{Outlook}

% bibtex bibliography
\bibliographystyle{plain}
\bibliography{tutorial04.bib}

\end{document}
